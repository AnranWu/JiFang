# 浅谈树链剖分

## 前置知识

①dfs序

②线段树





## 问题引入

> 给定一棵$$n$$个结点的树和$$m$$个操作。
>
> 操作有2种类型：
>
> 1.将树从 $$x$$ 到 $$y$$ 结点最短路径上所有节点的值都加上$$z$$。
>
> 2.求树从 $$x$$ 到 $$y$$ 结点最短路径上所有节点的值之和。



**分析这个问题**

如果只有操作一，则可以用**树上差分**以$$O（n+m）$$的时间复杂度解决这个问题。

如果只有操作二，则可以用**$$lca$$**来$$O（n）$$地处理出每个结点到根结点的距离。

$$dis(x,y)=dis(root,x)+dis(root,y)-2*dis(root,lca)$$

时间复杂度为$$O（mlogn+n）$$。

【时间复杂度不是自己算的，树上差分也还不会，就大概知道一下先~】

参考博客[树链剖分详解](https://www.cnblogs.com/ivanovcraft/p/9019090.html)



那如果需要同时支持以上两种操作，以上两种做法合起来就显得不那么优秀了~

于是乎我们的树链剖分就闪亮登场了（当当当当~）





## 基本概念

学习树链剖分首先要明确几个基本概念。

**重儿子：**父亲结点的所有子树中，结点数最多的子树的根结点，就是父亲结点的重儿子

**轻儿子：**父亲结点出了重儿子以外的儿子

**重边：**父亲结点连接重儿子的边

**轻边：**父亲节点连接轻儿子的边

**重链：**由重边构成的链

**轻链：**由轻边构成的链

（如果有多个结点数相同且最大的儿子，则任意选择一个作为其重儿子）





## 树链剖分原理

相信大家一开始接触树链剖分没看到这些概念，一定是觉得很奇怪，这能有什么用？？

别着急，可爱的树链剖分要跟数据结构放在一起才能显示出它的妙用来。

接下来以**线段树**——维护区间问题非常经典的数据结构和树链剖分搭配在一起介绍树链剖分的用法。



大家看到把 **树** 和 **线段树** 这两个东西放在一起，第一反应一定是觉得他非常奇怪的，一个是图这种复杂的数据结构，另一个是处理区间问题的数据结构，感觉是八竿子打不着的。

别急，树和线段树之间其实只差了一个dfs序，dfs序=八竿子~



首先我们抛开树链剖分，看一棵树的任意一个结点的子树（包括自身）的dfs序一定是一段连续的区间，



![img](https://img-blog.csdnimg.cn/20190503203931811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzI2MjY3,size_16,color_FFFFFF,t_70)

例如上图的结点$$2$$，它的子树的dfs序为区间$$[2,5]$$。

分析易得，设$$size[i]$$表示结点$$i$$的子树结点数量（包括自身），$$dfn[i]$$表示结点$$i$$的dfs序

则可得结点$$i$$的子树的dfs序区间为$$[ dfn[i] , dfn[i]+size[i]-1 ]$$



现在加入树链剖分的基本概念，由于我们区分出了轻重儿子、轻重链、轻重边。

于是我们对dfs的规则进行一点点改变，即**当要dfs当前结点的儿子时，优先遍历当前结点的重儿子**。

这样的规则就能够保证，**一条重链上的dfs序必定是连续的**。

![](C:\Users\acm-27\Desktop\aaaa.png)

例如上图

$$1——4——9——13——14$$是一条重链，其dfs序为区间$$[1,5]$$

$$3——7$$是一条重链，其dfs序区间为$$[8,9]$$

$$2——6——11$$是一条重链，其dfs序区间为$$[10,12]$$

这是因为每一次都先dfs重儿子保证的。



同时观察上图，易得树链剖分的三个性质：

**1.叶节点没有重儿子**

**2.非叶节点有且只有1个重儿子**

**3.每一个节点，或者处于一条重链中，或者是一个叶子节点**

其实不处在任何一条重链中的叶子节点可以看成是由它自己一个结点构成的一条重链。



## 树链剖分代码实现

首先介绍代码里几个数组的含义

| 数组        | 解释                                                     |
| ----------- | -------------------------------------------------------- |
| $$fa[x]$$   | 结点x的父亲节点                                          |
| $$dep[x]$$  | 结点x的深度                                              |
| $$size[x]$$ | 以结点x为根结点的子树的节点数量（包含自身）              |
| $$son[x]$$  | 结点x的重儿子                                            |
| $$rk[x]$$   | dfs序为x的结点编号                                       |
| $$id[x]$$   | 结点x的dfs序                                             |
| $$top[x]$$  | 结点x所在的重链的深度最浅的结点（最高/最上面的一个结点） |

维护结点$$x$$到结点$$y$$这一段路径上的某个性质的时候





## 闲话家常

最近学了两块算法，悟出了一点点小经验，就是学一个东西吧，先百度，抓着一篇博客就看看，然后看个大概，看第一遍大概率是看不懂的，然后可以点开其他搜索到的博客结合在一起看，互为补充。这篇博客没说清楚的问题，去别的博客康康有没有讲得更清楚一点，多看看慢慢就能看懂了！感觉原理懂得差不多的话，就去找道模板题练练手。AC之后原理也明白了，实现也大概清楚了，nice~





## 参考博客

[【博客】树链剖分瞎入门](https://www.nowcoder.com/discuss/175445?type=101)

[通俗易懂的树链剖分详解](https://www.luogu.com.cn/blog/yjpiaomiao/shulianpoufen)

[树链剖分详解](https://www.cnblogs.com/lykkk/p/10183778.html)

[专题·树链剖分【including 洛谷·【模板】树链剖分](https://blog.csdn.net/qq_43326267/article/details/89791152)

[树链剖分详解](https://www.cnblogs.com/ivanovcraft/p/9019090.html)